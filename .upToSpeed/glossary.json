[
  {
    "terms": [
      "Liquidity Provider"
    ],
    "definition": "# Liquidity Provider\n\nA participant who deposits assets into EulerSwap's liquidity pools, benefiting from unique capital efficiency advantages over traditional AMMs. Rather than having assets sit idle, liquidity providers' funds are placed in Euler's lending vaults, simultaneously facilitating trades, earning lending yield, and serving as collateral. EulerSwap enables just-in-time liquidity through on-demand borrowing, allowing a single position to support multiple trading pairs with up to 40x deeper effective liquidity. Providers can implement risk-neutral strategies through dynamic hedging, and customize their exposure using EulerSwap's flexible AMM curve with asymmetric liquidity distribution. While offering superior capital efficiency and multiple yield sources, liquidity providers must monitor potential liquidation risks if collateral values decline relative to borrowed assets."
  },
  {
    "terms": [
      "Volatility"
    ],
    "definition": "# Volatility\n\nVolatility refers to the magnitude and frequency of price changes between assets in a market. In EulerSwap, volatility is a critical consideration that influences AMM curve design and risk management. The protocol accommodates different volatility profiles through configurable parameters such as `priceX`, `priceY`, `concentrationX`, and `concentrationY`, which define the shape and behavior of liquidity curves.\n\nFor highly volatile pairs, EulerSwap's configurable AMM curves can be adjusted to provide deeper liquidity where needed, while for stable pairs, tighter curves can increase capital efficiency. Volatility directly impacts swap pricing, slippage, and the risk of impermanent loss for liquidity providers.\n\nWhen calculating swap amounts, EulerSwap uses boundary analysis to ensure operations remain within safe numerical limits even during periods of extreme volatility. The protocol's integration with Euler credit vaults provides additional protection against volatility by enabling just-in-time liquidity and reducing the need for idle capital in multiple fragmented pools."
  },
  {
    "terms": [
      "Arbitrage"
    ],
    "definition": "# Arbitrage\n\nArbitrage in EulerSwap refers to the practice of exploiting price differences between the AMM and external markets to generate risk-free profits. When EulerSwap's internal pricing mechanism (based on its custom AMM curve) diverges from external market prices, traders can execute opposing transactions across platforms to capture the difference. \n\nThis activity is essential to EulerSwap's design as it:\n\n1. Ensures price alignment between the protocol and broader markets\n2. Enhances capital efficiency by quickly resolving pricing inefficiencies \n3. Provides a mechanism for price discovery when market conditions change\n\nThe codebase specifically accounts for arbitrage behavior in its swap testing (with tests like `test_pathIndependent` and `test_fuzzAll`), and protocol designers consider arbitrage impacts in their roadmap discussions (e.g., \"losing a chunk of interest to arbitrage\" in the TODO file).\n\nEulerSwap's deep liquidity model, which allows up to 40x the liquidity depth of traditional AMMs through credit vault integration, creates a unique arbitrage environment where price corrections can happen with significantly less slippage than in conventional pools."
  },
  {
    "terms": [
      "Slippage"
    ],
    "definition": "# Slippage\n\nSlippage in EulerSwap refers to the difference between the expected output amount of a token swap (quoted at transaction submission time) and the actual output received when the transaction executes on-chain. \n\nWhen users initiate swaps through the periphery contract, they specify a minimum acceptable output amount (`amountOutMin`). If market conditions change while the transaction is pending and the actual output would be less than this minimum, the transaction reverts with `AmountOutLessThanMin` error rather than executing at an unfavorable price.\n\nThis protection mechanism is critical in decentralized exchanges because:\n\n1. Block times create delays between transaction submission and execution\n2. Other transactions can alter pool reserves and pricing\n3. Large swaps can significantly impact the AMM curve\n\nThe implementation in EulerSwap also handles edge cases like supply cap limitations, which can affect available liquidity and potentially increase slippage. Users should set appropriate slippage tolerances based on market volatility, transaction size, and time sensitivity of their trades."
  },
  {
    "terms": [
      "Spread"
    ],
    "definition": "# Spread\n\nIn the context of decentralized exchanges like EulerSwap, \"spread\" refers to the technique of distributing large trading orders over time rather than executing them all at once. This mechanism helps reduce market impact, minimize price slippage, and maintain liquidity stability.\n\nWhen large trades are spread across multiple smaller transactions, they create less price volatility than a single large trade would. This approach is often implemented through systems like Time-Weighted Average Market Makers (TWAMM), which automatically divide orders into smaller chunks executed at regular intervals.\n\nIn EulerSwap's implementation, this concept works alongside other capital efficiency features like just-in-time liquidity and shared liquidity pools. The system parameters (as seen in test files where values like `0.4e18, 0.85e18` are passed to `createEulerSwap`) help configure how trades are balanced and executed across time, effectively managing the \"spread\" of trading impact.\n\nSpread mechanisms benefit both traders (by reducing slippage on large orders) and liquidity providers (by protecting against sudden imbalances), contributing to more efficient and stable decentralized markets."
  },
  {
    "terms": [
      "Order Book"
    ],
    "definition": "# Order Book\n\nIn the context of EulerSwap, an Order Book is not a traditional listing of buy and sell orders, but rather a mathematical implementation that achieves similar functionality through parametric pricing curves. Unlike conventional order books that maintain explicit lists of limit orders, EulerSwap uses a hybrid approach that combines AMM (Automated Market Maker) liquidity with order book-like trading functionality.\n\nThe system calculates trading boundaries and prices using specialized functions like `computeQuote` and `getLimits`, which simulate limit order behavior without requiring an actual order book structure. It employs customizable concentration parameters (like `concentrationX`) to control the AMM curve's shape, creating more efficient pricing than traditional constant product AMMs.\n\nEulerSwap's Order Book functionality is further enhanced by its integration with Euler credit vaults, which provide up to 40x the liquidity depth of traditional AMMs by making idle assets more efficient. This approach enables limit order-like behavior, precise price execution, and just-in-time liquidity across multiple asset pairs simultaneously, while maintaining the composability advantages of AMMs."
  },
  {
    "terms": [
      "Market Depth"
    ],
    "definition": "# Market Depth\n\nMarket depth in EulerSwap refers to the amount of liquidity available in a pool to facilitate trades at or near the current market price without causing significant price slippage. Unlike traditional AMMs, EulerSwap enhances market depth through several mechanisms:\n\n1. **Credit Vault Integration** - By borrowing from Euler credit vaults using input tokens as collateral, EulerSwap can provide up to 40x the liquidity depth of traditional AMMs.\n\n2. **Cross-Collateralized Liquidity** - A single credit vault can support multiple asset pairs, increasing capital efficiency by sharing liquidity across pools rather than fragmenting it.\n\n3. **Adaptive AMM Curves** - EulerSwap implements customizable AMM mechanics with parameters like `concentrationX` that determine how liquidity is distributed around current prices, allowing for deeper liquidity where it's most needed.\n\n4. **Reserve Management** - The protocol carefully manages `currReserve0` and `currReserve1` to optimize the amount of tokens available for swaps at different price points.\n\nGreater market depth translates directly to better trading execution, allowing users to execute larger trades with minimal price impact. The protocol's market depth parameters can be monitored through functions like `getLimits()`, which returns the maximum amount that can be traded in each direction for a given asset pair."
  },
  {
    "terms": [
      "Limit Order"
    ],
    "definition": "# Limit Order\n\nIn the context of EulerSwap, a \"Limit Order\" represents a system of dynamic constraints that determine the maximum amount of tokens that can be swapped in a transaction. Unlike traditional limit orders that execute at specific price points, EulerSwap implements limits through the `getLimits()` function which returns two key values:\n\n- **inLimit**: The maximum amount of input token that can be provided\n- **outLimit**: The maximum amount of output token that can be received\n\nThese limits are calculated based on multiple factors:\n1. Supply and borrow caps from the underlying vaults\n2. Current reserves in the liquidity pool\n3. Account balances and available credit\n4. Protocol-level risk parameters\n\nThe system enforces these limits during swap operations, reverting transactions with `SwapLimitExceeded` when an operation would violate the established boundaries. This mechanism protects both users and the protocol by preventing over-borrowing, maintaining adequate reserves, and ensuring the AMM remains solvent under all conditions.\n\nRather than allowing users to place arbitrary orders at specific prices, EulerSwap's limit mechanism functions as a risk management system that maintains the integrity of its credit-backed liquidity model."
  },
  {
    "terms": [
      "Stop-Loss Order"
    ],
    "definition": "# Stop-Loss Order\n\nA Stop-Loss Order in EulerSwap is an automated risk management mechanism that allows traders to set predefined price thresholds at which their positions will automatically be closed to limit potential losses. When the asset's price reaches this threshold, the order is triggered, executing a swap to sell the asset at the current market price.\n\nUnlike limit orders which execute at a specific price or better, stop-loss orders trigger immediately once the price threshold is crossed, typically executing as market orders. In EulerSwap's implementation, these orders are executed entirely on-chain, leveraging the protocol's integration with Euler credit vaults to access deeper liquidity pools, potentially resulting in better execution even during volatile market conditions.\n\nThe implementation uses customizable hooks (particularly visible in the Uniswap v4 Hook compatibility) to monitor price feeds and automatically trigger the appropriate swap when conditions are met. This removes the need for manual monitoring and provides traders with a trustless, non-custodial way to enforce disciplined risk management without active intervention.\n\nWhen setting up a stop-loss order, users define their risk tolerance by specifying the maximum acceptable loss, allowing them to protect their portfolio from significant downside while still participating in potential upside."
  },
  {
    "terms": [
      "Maker Fee"
    ],
    "definition": "# Maker Fee\n\nIn EulerSwap, a \"Maker Fee\" refers to the fee structure applied to liquidity providers who contribute to the protocol's automated market maker (AMM) system. Unlike traditional exchanges that distinguish between maker and taker fees, EulerSwap implements an integrated fee approach that works with its credit vault-based liquidity model.\n\nThe protocol defines fee parameters in WAD format (1e18 precision) that are converted to percentage points when interacting with Uniswap V4 hooks:\n\n```solidity\n// convert fee in WAD to pips. 0.003e18 / 1e12 = 3000 = 0.30%\nuint24 fee = uint24(p.fee / 1e12);\n```\n\nThe system enforces strict validation on fees with minimum and maximum boundaries, preventing excessive fees during pool deployment. Additionally, EulerSwap implements a separate protocol fee system that can only be activated under specific conditions, including a 365-day timelock after deployment.\n\nEulerSwap's fee model is unique due to its integration with Euler credit vaults, where liquidity providers earn rewards through a cross-collateralized system that allows a single vault to support multiple asset pairs simultaneously, increasing capital efficiency beyond traditional AMM designs."
  },
  {
    "terms": [
      "Taker Fee"
    ],
    "definition": "# Taker Fee\n\nIn EulerSwap, a taker fee is a configurable fee percentage deducted from swap transactions when users exchange tokens through the protocol. This fee is distinct from standard protocol fees and is applied when traders \"take\" liquidity from the pool. The fee is calculated as a percentage of the input amount and is incorporated into the swap calculations, ensuring that the quoted output amounts account for this deduction. For example, with a 5% taker fee, a user swapping 100 tokens would effectively have 95 tokens used for the actual swap while 5 tokens are collected as the fee. These fees contribute to the protocol's value accrual mechanism and can be directed to specific recipients. EulerSwap implements this through its fee parameter in swap creation, as demonstrated in test cases like `test_fees_exactIn` where fees are set to values like `0.05e18` (5%)."
  },
  {
    "terms": [
      "Margin Trading"
    ],
    "definition": "# Margin Trading\n\nMargin trading in DeFi platforms like EulerSwap enables users to borrow assets against their deposited collateral to increase their trading position sizes. Through integration with lending vaults, EulerSwap allows traders to execute larger swaps than their personal funds would permit by automatically borrowing the necessary output tokens and using input tokens as collateral.\n\nThis mechanism provides several key benefits:\n- **Increased capital efficiency**: A single pool of assets can simultaneously serve as liquidity for swaps and collateral for loans\n- **Deeper liquidity**: EulerSwap can support up to 40x the liquidity depth of traditional AMMs by leveraging borrowed assets\n- **Cross-collateralization**: Positions can be secured across multiple asset pairs simultaneously\n\nThe code handles this through functions tracking user debt (`myDebt`), balances (`myBalance`), and enforcing borrowing limits (`debtLimit0`, `debtLimit1`). Safety mechanisms include checks for supply and borrow caps to prevent over-leveraging.\n\nWhile margin trading amplifies potential returns, it equally magnifies risk. If collateral values fall below required thresholds, positions may be subject to liquidation as evidenced by functions that test for cap exceedances and monitor user net asset value (NAV)."
  },
  {
    "terms": [
      "Leverage"
    ],
    "definition": "# Leverage\n\nIn EulerSwap, leverage refers to the protocol's ability to amplify liquidity depth by using collateral to borrow assets on demand. When a user initiates a swap, EulerSwap borrows the required output token using the input token as collateral through Euler's credit vaults. This mechanism enables up to 40x the effective liquidity depth compared to traditional AMMs without requiring liquidity providers to pre-fund both sides of a trading pair.\n\nThe leverage system works through \"EulerSwap operators\" - specialized smart contracts that manage an LP's position by automatically depositing incoming tokens as collateral, borrowing the necessary output tokens, and rebalancing positions after trades. This approach makes idle assets in Euler more efficient, as a single deposit can support multiple trading pairs simultaneously through cross-collateralization.\n\nUnlike traditional leverage in trading (where users manually take on debt to increase position size), EulerSwap's leverage is built into the protocol's infrastructure, creating just-in-time liquidity that dynamically responds to trade demand while maintaining capital efficiency for liquidity providers."
  },
  {
    "terms": [
      "Hedging"
    ],
    "definition": "# Hedging\n\nHedging in EulerSwap refers to a risk management strategy that allows liquidity providers to neutralize their exposure to price volatility while still earning yields. EulerSwap makes hedging uniquely efficient through its integrated credit vault system, which enables:\n\n1. **Delta-neutral strategies** - Liquidity providers can borrow one asset (e.g., ETH) using another as collateral (e.g., USDC) to provide liquidity to trading pairs without direct exposure to price movements.\n\n2. **Dynamic hedging** - Providers can periodically rebalance their borrowing positions to match exposure on LP positions by simply uninstalling and reinstalling their EulerSwap operator, avoiding costly external swaps.\n\n3. **Capital efficiency** - Unlike traditional systems where providers must borrow from one protocol to supply liquidity to another, EulerSwap combines lending and liquidity provision in a single system, reducing gas costs and operational overhead.\n\n4. **Advanced applications** - The platform supports sophisticated strategies like funding rate arbitrage with perpetual futures markets and capital-efficient liquidity for new tokens.\n\nThis approach significantly reduces impermanent loss risk while maintaining or enhancing returns from trading fees, making EulerSwap particularly valuable for professional market makers and sophisticated liquidity providers."
  },
  {
    "terms": [
      "Futures"
    ],
    "definition": "# Futures\n\nIn the context of EulerSwap, \"Futures\" are not a native protocol feature. The platform focuses on spot trading with enhanced capital efficiency through integration with Euler credit vaults. Unlike traditional futures contracts that enable trading of assets at predetermined future prices, EulerSwap's architecture centers on an automated market maker (AMM) that provides deep liquidity for immediate swaps by leveraging lending pools. \n\nWhile the protocol implements flexible pool configurations and customizable AMM curves that optimize swap pricing, it does not offer derivatives or futures trading functionality in its current implementation. The system instead achieves capital efficiency through just-in-time liquidity provision and cross-collateralized credit vaults that support multiple asset pairs simultaneously, reducing the inefficiencies typical of traditional AMMs.\n\nEulerSwap's architecture does include time-sensitive components like swap deadlines (as seen in `test_SwapDeadline()`) and utilization limits, but these are standard DEX features rather than futures trading mechanisms."
  },
  {
    "terms": [
      "Options"
    ],
    "definition": "# Options\n\nIn the context of EulerSwap, \"Options\" refer to configurable parameters that determine the behavior and properties of liquidity pools and swaps. These options include:\n\n1. **Curve Parameters** - Settings like slope (e.g., 0.4e18) and curvature (e.g., 0.85e18) that define the mathematical curve used for pricing assets during swaps.\n\n2. **Liquidity Configuration** - Parameters that determine the initial amounts of tokens in a pool, which can be symmetric or asymmetric (one-sided).\n\n3. **Fee Settings** - Configurable swap fees (e.g., 0.001e18 for 10 basis points) that determine the cost of transactions.\n\n4. **Collateral Ratios** - Loan-to-Value (LTV) settings that control how assets can be used as collateral in the system.\n\n5. **Price Scaling Factors** - Parameters that help normalize prices between assets with different decimal places or value ranges.\n\nThese options are typically encoded in a standardized `Params` structure (384 bytes in length) that gets appended to transaction calldata when interacting with the protocol. By adjusting these parameters, liquidity providers and protocol developers can customize the behavior of pools to optimize for capital efficiency, risk management, and pricing accuracy."
  },
  {
    "terms": [
      "Derivatives"
    ],
    "definition": "# Derivatives\n\nIn the context of EulerSwap, \"derivatives\" refers to mathematical derivatives (from calculus) that calculate the rate of change of one value with respect to another. Specifically, EulerSwap uses derivatives to determine the slope of its custom automated market maker (AMM) curves, which directly translates to the marginal price at any point during a swap.\n\nThe core implementation in `CurveExtrasLib.sol` includes the `df_dx` function which calculates the derivative of the AMM curve:\n\n```solidity\nfunction df_dx(uint256 x, uint256 px, uint256 py, uint256 x0, uint256 c) internal pure returns (int256) {\n    uint256 r = Math.mulDiv(x0 * x0 / x, 1e18, x, Math.Rounding.Ceil);\n    return -int256(px * (c + (1e18 - c) * r / 1e18) / py);\n}\n```\n\nThis derivative function is essential for:\n\n1. Determining the instantaneous exchange rate at any point on the curve\n2. Implementing EulerSwap's hybrid curve that combines properties of constant-sum and constant-product AMMs\n3. Enabling the liquidity concentration parameter (c) to modify price impact based on distance from equilibrium\n\nThe whitepaper formalizes this as `dy/dx = -px/py * [c + (1-c)(x0/x)²]`, where the derivative represents how much output token y changes when input token x changes by an infinitesimal amount - effectively the spot price."
  },
  {
    "terms": [
      "Stablecoin"
    ],
    "definition": "# Stablecoin\n\nA cryptocurrency designed to maintain a stable value relative to a specific asset or basket of assets, typically pegged to a fiat currency like the US dollar. In the context of EulerSwap, stablecoins play a critical role as the primary trading pairs (\"stable-stable pairs\") due to their predictable price relationships. This focus enables EulerSwap to optimize its AMM curve and credit vault integration for maximum capital efficiency when swapping between assets of similar value. Stablecoins in EulerSwap benefit from concentrated liquidity ranges, allowing for deeper liquidity and minimal slippage. The protocol includes specific mechanisms to track reserves, manage debt limits, and verify trades to maintain appropriate ratios between stablecoins, ensuring they remain properly pegged while efficiently utilizing liquidity."
  },
  {
    "terms": [
      "Collateral"
    ],
    "definition": "# Collateral\n\nAssets provided by users to secure a position or transaction within EulerSwap's DeFi protocol. Collateral enables capital-efficient swaps by allowing the protocol to borrow output tokens against input tokens, effectively increasing liquidity depth up to 40x compared to traditional AMMs. When a user swaps Token A for Token B, Token A is automatically used as collateral to borrow Token B from Euler's lending vaults. This model supports dynamic reallocation between collateral types without affecting existing loans, as demonstrated in the CollateralSwap tests. The protocol manages risk through loan-to-value (LTV) ratios, borrow caps, and liquidation mechanisms that protect against market volatility. Uniquely, EulerSwap's cross-collateralized structure allows a single credit vault to support multiple asset pairs simultaneously, enhancing capital efficiency by eliminating the need for liquidity providers to fund both sides of each trading pair."
  },
  {
    "terms": [
      "Yield Farming"
    ],
    "definition": "# Yield Farming\n\nYield farming in EulerSwap refers to the strategy where users deposit assets into Euler credit vaults to provide liquidity for the automated market maker (AMM). While depositing tokens, users can track their contributions through functions like `myBalance()` and `myDebt()`, with the system maintaining precise accounting of each provider's share.\n\nUnlike traditional AMMs that fragment liquidity across multiple pools, EulerSwap enables a single cross-collateralized credit vault to support multiple asset pairs simultaneously, potentially increasing capital efficiency and yields. The platform's architecture, with functions like `depositAssets()` and `withdrawAssets()`, creates the foundation for liquidity provision while the flexible AMM curve optimizes swap pricing.\n\nThough explicit reward distribution logic isn't directly shown in the codebase, EulerSwap's design supports customizable AMM mechanics and greater control for liquidity providers. This modularity allows for implementing various incentive structures where providers could earn not only from trading fees but potentially additional protocol-defined rewards proportional to their contribution and participation duration.\n\nThe system's compatibility with standard DeFi patterns means yield farming strategies can be developed on top of EulerSwap's liquidity provision layer, offering opportunities for enhanced returns through its capital-efficient model."
  },
  {
    "terms": [
      "Staking"
    ],
    "definition": "# Staking\n\nIn EulerSwap, staking refers to a mechanism where users deposit tokens into a designated smart contract for a period of time to earn rewards. Users can stake tokens to participate in reward streams where they can earn up to five different reward tokens simultaneously. The staking system operates on an epoch-based model with predefined durations (between 1-10 weeks) that creates predictable reward distribution schedules. This mechanism serves multiple purposes: it encourages long-term token holding, provides additional yield opportunities to participants, and potentially contributes to protocol security through a Safety Module that acts as collateralization for the system. Staking complements EulerSwap's primary function as an automated market maker (AMM) by creating incentives for sustained protocol participation and liquidity provision within the ecosystem."
  },
  {
    "terms": [
      "APR (Annual Percentage Rate)",
      "APR",
      "Annual Percentage Rate"
    ],
    "definition": "# APR (Annual Percentage Rate)\n\nAnnual Percentage Rate in EulerSwap represents the annualized rate of return that liquidity providers can expect to earn from their capital contributions to liquidity pools. It is calculated by dividing the total fees earned over a specific period by the total value locked (TVL) in the pool, then annualizing this rate.\n\nUnlike some DeFi protocols, EulerSwap doesn't explicitly implement APR calculations within its smart contracts. Instead, it provides the underlying fee structure through the `feeMultiplier` parameter, which directly impacts potential returns:\n\n```solidity\nuint256 public immutable feeMultiplier;\n```\n\nEulerSwap's unique integration with Euler credit vaults creates a different APR profile compared to traditional AMMs. By enabling up to 40x the liquidity depth through efficient use of idle assets, the protocol can potentially generate different fee patterns that affect APR calculations.\n\nWhen evaluating APR in EulerSwap, users should consider several factors:\n- Trading volume and resulting fee generation\n- Liquidity depth enabled by the credit vault integration\n- Position-specific parameters that affect capital efficiency\n- Borrowing caps and limits that influence available liquidity\n\nFor accurate APR estimations, external tools or interfaces would need to incorporate these EulerSwap-specific mechanics to provide meaningful APR projections for liquidity providers."
  },
  {
    "terms": [
      "APY (Annual Percentage Yield)",
      "APY",
      "Annual Percentage Yield"
    ],
    "definition": "# APY (Annual Percentage Yield)\n\nThe annual rate of return for liquidity providers in EulerSwap's decentralized exchange. APY is primarily derived from trading fees collected when users execute swaps within liquidity pools. These fees are distributed proportionally among liquidity providers based on their share of the pool.\n\nEulerSwap's unique architecture can potentially offer enhanced APY through several mechanisms:\n- Integration with Euler credit vaults providing up to 40× liquidity depth compared to traditional AMMs\n- Cross-collateralized pools that reduce capital fragmentation across multiple trading pairs\n- Customizable AMM curves (via concentrationX and concentrationY parameters) that optimize fee generation\n\nWhile APY represents potential returns, it's influenced by factors including trading volume, pool size, fee multiplier settings, and market conditions. Liquidity providers must also consider impermanent loss, which occurs when token price ratios change unfavorably. The actual realized returns depend on whether collected fees (reflected in APY) exceed any impermanent loss experienced during the liquidity provision period."
  },
  {
    "terms": [
      "Gas Fee"
    ],
    "definition": "# Gas Fee\n\nIn blockchain systems like EulerSwap, a gas fee is a cost paid by users to execute transactions on the network. Within EulerSwap specifically, there are two fee concepts:\n\n1. **Network Gas Fees**: The standard Ethereum transaction costs paid to validators for processing transactions.\n\n2. **Protocol Fees**: A percentage-based fee (between MIN_PROTOCOL_FEE and MAX_PROTOCOL_FEE) collected by the EulerSwap protocol on swap transactions. These fees:\n   - Can only be enabled after 365 days from deployment\n   - Require a designated fee recipient\n   - Are calculated as a percentage of the input token amount\n   - Feature careful rounding mechanics to ensure fair pricing\n\nThe protocol includes several gas optimization techniques to minimize the overall transaction costs for users, including efficient storage packing and optimized fee calculations. For example, when quoting exact output swaps, the protocol doesn't need to round up fees because the actual fee is calculated using fixed-point arithmetic that naturally rounds down during division operations.\n\nThe EulerSwap codebase demonstrates how protocol designers must balance fee collection (for sustainability) with gas efficiency (for user experience), illustrating the complex considerations required when building on gas-fee-based blockchain networks."
  },
  {
    "terms": [
      "Smart Contract"
    ],
    "definition": "# Smart Contract\n\nA smart contract is a self-executing computer program deployed on a blockchain that automatically enforces predefined rules and conditions without requiring intermediaries. In EulerSwap, smart contracts form the foundation of the decentralized exchange, implementing sophisticated automated market-making algorithms, managing liquidity pools, and facilitating token swaps.\n\nThe key characteristics of smart contracts in this context include:\n\n- **Self-execution**: Smart contracts automatically execute trades when conditions are met, without requiring manual intervention.\n- **Trustless operation**: By encoding business logic in immutable code, smart contracts eliminate the need for trusted third parties to facilitate transactions.\n- **Deterministic outcomes**: Given the same inputs, smart contracts always produce the same outputs, making behavior predictable.\n\nIn EulerSwap's implementation, smart contracts enable several advanced features:\n- Integration with Euler credit vaults to provide up to 40x liquidity depth\n- Just-in-time liquidity provision through cross-collateralized lending\n- Flexible AMM curves for optimized swap pricing\n- Shared liquidity across multiple asset pairs\n\nThese contracts are written in Solidity (for Ethereum-based platforms), deployed with specific addresses across different networks, and follow security best practices including modular design and comprehensive testing to ensure reliable operation of the decentralized exchange."
  },
  {
    "terms": [
      "DeFi"
    ],
    "definition": "# DeFi\n\nDecentralized Finance (DeFi) represents a blockchain-based financial ecosystem that replaces traditional intermediaries with smart contracts and protocol-governed systems. In the context of platforms like EulerSwap, DeFi integrates lending, borrowing, and trading in capital-efficient ways. \n\nKey innovations include cross-collateralized credit vaults where assets simultaneously serve as collateral and liquidity sources, just-in-time liquidity provision that amplifies capital efficiency up to 40x compared to traditional AMMs, and customizable liquidity curves that enable specialized trading strategies.\n\nDeFi's core value proposition is visible in how EulerSwap combines Euler Finance's lending protocol with AMM functionality, allowing users to maintain collateralized debt positions while participating in trading activities. This integration demonstrates DeFi's fundamental characteristic of composability, where protocols build upon each other to create more sophisticated financial services with greater capital efficiency, transparency, and programmability than traditional finance."
  },
  {
    "terms": [
      "CeFi"
    ],
    "definition": "# CeFi\n\nCentralized Finance (CeFi) refers to cryptocurrency financial services operated by centralized institutions that act as intermediaries between users and blockchain networks. In the context of EulerSwap, CeFi represents the traditional financial infrastructure that the protocol can interact with through its periphery contracts. While EulerSwap operates primarily as a DeFi protocol—providing automated market making with credit vault integration—it maintains capabilities to interface with centralized exchanges and services. This interaction is evident in functions like `withdrawAssets` and `depositAssets`, which manage the flow of assets between centralized and decentralized components. CeFi platforms provide important benefits like regulatory compliance, simplified user interfaces, and connections to traditional banking, serving as complementary infrastructure to EulerSwap's decentralized liquidity provision mechanisms. Understanding CeFi is essential for comprehending how EulerSwap bridges traditional financial systems with its innovative AMM approach."
  },
  {
    "terms": [
      "DAO"
    ],
    "definition": "# DAO\n\nA Decentralized Autonomous Organization (DAO) is a blockchain-based governance structure where decision-making power is distributed among token holders rather than centralized in a traditional hierarchical organization. DAOs typically include community-driven decision making through governance forums and voting mechanisms, which allow token holders to collectively propose, debate, and implement protocol changes and funding decisions.\n\nIn the context of EulerSwap, a DAO would likely govern the protocol's parameters (such as swap fees), manage treasury assets, and authorize protocol upgrades. The codebase shows infrastructure for operator authorization (via `setAccountOperator` calls) and parameter configuration that would typically be controlled through DAO governance. While EulerSwap was developed by Euler Labs Ltd., the governance structure may operate as a DAO where stakeholders collectively make decisions about the protocol's future development and operation.\n\nDAOs enable communities to manage resources and make decisions in a decentralized manner, embodying key principles of decentralized governance that align with the broader ethos of DeFi projects like EulerSwap."
  },
  {
    "terms": [
      "Liquidity Mining"
    ],
    "definition": "# Liquidity Mining\n\nLiquidity mining in EulerSwap represents an evolved form of the traditional DeFi incentive mechanism. Rather than simply staking assets in a shared pool for token rewards, EulerSwap liquidity providers deposit assets into Euler credit vaults, where they simultaneously support trading activities, earn lending yield, and serve as collateral for borrowing.\n\nThe key innovation is that liquidity in EulerSwap can be used far more efficiently. When a user initiates a swap, the protocol can borrow the required output token using the input token as collateral (up to 40x traditional AMM liquidity depth). This \"just-in-time\" liquidity model allows a single LP position to support multiple trading pairs through cross-collateralization.\n\nUnlike traditional liquidity mining where rewards come primarily from protocol tokens, EulerSwap LPs earn from:\n- Trading fees generated by swaps\n- Yield from lending activities in Euler vaults\n- Capital efficiency gains through cross-collateralized positions\n\nEulerSwap's approach to liquidity mining significantly reduces capital inefficiencies while providing deeper markets, lower costs, and greater control for liquidity providers, effectively transforming how incentives are structured in DeFi liquidity provision."
  },
  {
    "terms": [
      "Protocol Fee"
    ],
    "definition": "# Protocol Fee\n\nA protocol fee in EulerSwap is a percentage of transaction fees collected by the protocol from swap operations. These fees range from 10% to 25% of the liquidity provider fees and are denominated in WAD units (where 0.10e18 represents 10%). \n\nProtocol fees have several key characteristics:\n- They can only be enabled after a 1-year timelock period from deployment\n- A fee recipient address must be designated before fees can be activated\n- Only the owner can adjust the fee percentage within the defined limits\n- The fees generate revenue for protocol maintenance and development\n\nThe implementation includes safety mechanisms like minimum and maximum boundaries, governance controls, and transparent fee collection. When a swap occurs, a portion of the fee is automatically sent to the designated protocol fee recipient rather than being added to the liquidity pool reserves.\n\nProtocol fees represent an important balance between generating sustainable revenue for the protocol while ensuring the system remains attractive for users and liquidity providers."
  },
  {
    "terms": [
      "ERC20"
    ],
    "definition": "# ERC20\n\nERC20 is a technical standard for fungible tokens on the Ethereum blockchain that defines a common interface implemented by smart contracts. The standard specifies six mandatory functions (`totalSupply`, `balanceOf`, `transfer`, `transferFrom`, `approve`, and `allowance`) and two events (`Transfer` and `Approval`), enabling tokens to be transferred between addresses and allowing third-party spending approval. In EulerSwap, ERC20 tokens serve as the assets being swapped, with the protocol extensively interfacing with these tokens through approvals, transfers, deposits, and withdrawals. EulerSwap extends standard ERC20 functionality by integrating with Permit2 for gasless approvals and implementing ERC4626 vault standards to support its credit-based liquidity model. The protocol's architecture depends on ERC20 compatibility to create liquidity pools, manage collateral in credit vaults, and implement its automated market maker functionality."
  },
  {
    "terms": [
      "ERC1155"
    ],
    "definition": "# ERC1155\n\nA token standard that allows for the creation and management of multiple token types within a single smart contract. It supports both fungible and non-fungible tokens, enables batch transfers, and provides more gas-efficient operations compared to separate ERC20 or ERC721 contracts. ERC1155 is particularly valuable in DeFi applications like EulerSwap where managing multiple asset types efficiently is essential, as it reduces gas costs and simplifies operations when handling various tokens in liquidity pools, collateral positions, or asset swaps."
  },
  {
    "terms": [
      "ERC6909"
    ],
    "definition": "# ERC6909\n\nERC6909 is a gas-efficient standard for managing multiple fungible tokens within a single contract. In the context of EulerSwap, it's used to interface with Uniswap v4's PoolManager and facilitate efficient token operations across multiple trading pairs. The standard provides a minimalist implementation that handles multiple token IDs within the same contract, reducing gas costs compared to managing separate ERC20 tokens.\n\nKey features in EulerSwap's implementation include:\n- Supporting multi-token accounting through Uniswap v4's hook system\n- Simplified mint/burn mechanics that replace traditional approve/transfer flows\n- Efficient balance tracking for token swaps and liquidity management\n\nThe integration helps EulerSwap achieve its goal of providing deeper liquidity by making idle assets in Euler's credit vaults more efficient. When EulerSwap deploys a pool, it creates the necessary infrastructure using ERC6909's token accounting system, allowing for gas-optimized token transfers during swaps and other operations."
  },
  {
    "terms": [
      "X96"
    ],
    "definition": "# X96\n\nA fixed-point number format used in decentralized exchanges to represent numerical values with high precision. In this format, a floating-point number is multiplied by 2^96 and stored as an integer. The X96 format is particularly important for representing price ratios and their square roots in automated market makers like EulerSwap. Since Solidity lacks native floating-point types, this representation enables efficient and accurate mathematical operations in smart contracts while minimizing rounding errors and gas costs. X96 values can be recognized in code by variables containing \"X96\" in their names or operations involving bit-shifting by 96 places."
  },
  {
    "terms": [
      "Concentrated Liquidity"
    ],
    "definition": "# Concentrated Liquidity\n\nIn EulerSwap, concentrated liquidity refers to a protocol-level mechanism that shapes how liquidity is distributed along the price curve using the `concentrationX` and `concentrationY` parameters. Unlike Uniswap V3's user-selected price ranges, EulerSwap applies concentration globally to the entire pool, allowing the protocol to focus liquidity more densely around equilibrium prices.\n\nThe concentration parameters customize the AMM curve's behavior, creating a spectrum between constant-product and constant-sum models. When concentration parameters approach 1, the curve becomes more like a constant-sum AMM (focused liquidity); when they approach 0, it behaves more like a traditional constant-product AMM (diffuse liquidity).\n\nThis mechanism achieves similar capital efficiency benefits as Uniswap V3's per-LP concentrated liquidity but applies them protocol-wide: deeper liquidity near market prices, reduced price impact for common trades, and more efficient capital utilization. The verification function in EulerSwap uses these concentration parameters to ensure trades follow the custom curve, maintaining the desired liquidity distribution."
  },
  {
    "terms": [
      "Constant Product Formula"
    ],
    "definition": "# Constant Product Formula\n\nIn EulerSwap, the Constant Product Formula represents a foundational mathematical principle that helps govern token exchange rates in liquidity pools. Traditionally expressed as `x * y = k` (where x and y are token reserves and k is a constant), EulerSwap extends this concept into a customizable hybrid formula:\n\n```\ny = y_0 + (p_x/p_y)(x_0 - x)(c_x + (1 - c_x)(x_0/x))\n```\n\nWhere:\n- `x_0`, `y_0` are equilibrium reserves\n- `p_x`, `p_y` are pricing parameters\n- `c_x` is a concentration parameter\n\nThis formula enables EulerSwap to smoothly transition between constant-sum behavior (`c_x = 1`) and constant-product behavior (`c_x = 0`), allowing for optimized liquidity distribution. The constant product component creates deeper liquidity at prices far from the equilibrium point, while maintaining capital efficiency.\n\nUnlike traditional AMMs, this implementation allows for customizable exchange rates at equilibrium and targeted liquidity concentration, making it possible to maintain more efficient markets while preserving the core benefits of permissionless, decentralized trading."
  },
  {
    "terms": [
      "Invariant"
    ],
    "definition": "# Invariant\n\nIn the context of automated market makers (AMMs) like EulerSwap, an invariant is a mathematical relationship between token reserves that must be maintained throughout all trading operations. This relationship defines the boundary of valid states for the liquidity pool and ensures the AMM's stability and fairness.\n\nUnlike Uniswap's simple constant-product formula (`x * y = k`), EulerSwap uses a more sophisticated invariant with parameterizable curves:\n\nFor reserves where `x ≤ x₀`:\n```\ny ≥ y₀ + (p_x/p_y)(x₀-x)(c_x + (1-c_x)(x₀/x))\n```\n\nFor reserves where `x ≥ x₀`:\n```\nx ≥ x₀ + (p_y/p_x)(y₀-y)(c_y + (1-c_y)(y₀/y))\n```\n\nWhere:\n- `x₀`, `y₀` are equilibrium reserves\n- `p_x`, `p_y` are price parameters\n- `c_x`, `c_y` are concentration parameters\n\nThese formulas create a boundary curve in the (x,y) plane. Any valid swap must result in reserves that lie on or above this curve. The `CurveLib.verify()` function enforces this invariant after each swap operation, reverting the transaction if the new state would violate the boundary conditions.\n\nThe invariant is crucial because it:\n1. Prevents value extraction through manipulative trades\n2. Ensures predictable pricing behavior\n3. Maintains liquidity provision guarantees\n4. Balances the AMM's capital efficiency with market safety\n\nEulerSwap's flexible invariant enables deeper liquidity and capital efficiency while still providing mathematical guarantees about the system's behavior."
  },
  {
    "terms": [
      "Mid Price"
    ],
    "definition": "# Mid Price\n\nIn EulerSwap's AMM architecture, the mid price represents the theoretical exchange rate between two tokens at the equilibrium point of a liquidity pool. It's calculated as the ratio of pricing parameters `priceX` and `priceY` (mid price = px/py), which are immutable values defined during pool creation.\n\nThe mid price serves as the slope of the trading function at equilibrium and forms the foundation of EulerSwap's innovative curve design. At this equilibrium point (x₀, y₀), the marginal price is exactly equal to the mid price, representing the price at which an infinitesimally small trade would execute without affecting the market.\n\nUnlike execution prices which vary with trade size due to slippage, the mid price remains constant until rebalanced. It's used for quoting functions, ensuring path independence in trading, and as a reference point for the hybrid AMM curve that combines constant-sum and constant-product properties through a concentration parameter.\n\nThe mid price implementation enables EulerSwap to create customizable AMM curves with concentrated liquidity around expected trading ranges, contributing to greater capital efficiency compared to traditional AMMs."
  },
  {
    "terms": [
      "AMM Protocol",
      "Automated Market Maker",
      "AMM"
    ],
    "definition": "# AMM Protocol\n\nAn Automated Market Maker (AMM) protocol is a decentralized exchange mechanism that uses mathematical formulas and smart contracts to enable token trading without traditional order books. In EulerSwap, the AMM protocol implements a customizable curve that interpolates between constant-sum and constant-product models through concentration parameters.\n\nCore components include:\n\n1. **Mathematical pricing curve**: \n   ```\n   y = y_0 + (p_x/p_y)(x_0 - x)(c_x + (1-c_x)(x_0/x))\n   ```\n   Where concentration parameters (c_x, c_y) control liquidity distribution around equilibrium points.\n\n2. **Invariant conditions** enforcing valid states for pool reserves.\n\n3. **Fee mechanism** applied to swaps (as seen in `QuoteLib.computeQuote`).\n\n4. **Capital efficiency** through integration with Euler credit vaults.\n\nThe AMM enables permissionless trading, with prices determined algorithmically based on current reserves and parameters rather than order matching. It uniquely supports customizable liquidity concentration, allowing pool creators to optimize for specific trading patterns and risk profiles while maintaining the core AMM property of continuous, smart-contract-enforced liquidity."
  },
  {
    "terms": [
      "address(0)"
    ],
    "definition": "# address(0)\n\nIn blockchain development, `address(0)` (also known as the zero address) refers to the Ethereum address `0x0000000000000000000000000000000000000000`. This special address serves as a sentinel value with several important uses:\n\n1. **Null or Uninitialized Value**: `address(0)` represents an uninitialized or default address in variables and storage slots, similar to how `null` works in other programming languages.\n\n2. **Token Burns**: Sending tokens to `address(0)` effectively removes them from circulation (burns them), since no one possesses the private key to this address.\n\n3. **Input Validation**: Smart contracts use checks like `require(addr != address(0))` to validate that meaningful addresses are provided in function parameters.\n\n4. **Contract Creation**: In low-level contract deployment operations, `address(0)` can appear as the zero value in assembly blocks using `create` or `create2`.\n\n5. **Permission Denial**: Some contracts use `address(0)` in access control mechanisms to represent \"no access\" or \"disabled\" states.\n\n6. **Safety Checks**: `address(0)` often appears in conditional logic that prevents dangerous operations on invalid addresses.\n\nThe proper handling of the zero address is critical for smart contract security, as failing to check for it can lead to locked funds, erroneous transfers, or vulnerable permission systems."
  },
  {
    "terms": [
      "EIP-1153"
    ],
    "definition": "# EIP-1153\n\nEIP-1153 (Transient Storage Opcodes) is an Ethereum Improvement Proposal that introduced new opcodes (`TLOAD` and `TSTORE`) for temporary storage in smart contracts. These opcodes provide a way to store data that persists only for the duration of a transaction, after which it's automatically discarded. Implemented in the Dencun upgrade, transient storage is significantly cheaper than regular storage operations (100 gas versus 2100+ gas for cold storage), making it valuable for gas optimization.\n\nIn DeFi applications like EulerSwap, transient storage is particularly useful for temporary calculations during complex operations like swaps, reentrancy protection, and cross-function communication within a single transaction. The feature enables protocols to optimize gas usage while maintaining security, supporting EulerSwap's goal of providing deeper liquidity with improved capital efficiency.\n\nSince Solidity 0.8.24, developers can use these opcodes through inline assembly, though they must carefully consider that data in transient storage doesn't persist between transactions and isn't accessible via view functions. This feature represents an important advancement in smart contract efficiency, allowing protocols to significantly reduce gas costs for temporary storage operations."
  },
  {
    "terms": [
      "DEX"
    ],
    "definition": "# DEX\n\nA Decentralized Exchange (DEX) is a peer-to-peer marketplace for trading cryptocurrencies directly through smart contracts without centralized intermediaries. In the context of EulerSwap, it represents an advanced AMM (Automated Market Maker) that integrates with Euler's credit vaults to provide deeper liquidity for swaps. \n\nUnlike traditional DEXs that rely solely on deposited assets in liquidity pools, EulerSwap uses a novel mechanism where idle assets in Euler's lending protocol become available for trading. When a user initiates a swap, an \"EulerSwap operator\" smart contract borrows the required output token using the input token as collateral, enabling up to 40x the liquidity depth of conventional DEXs.\n\nEulerSwap further enhances capital efficiency by allowing a single cross-collateralized credit vault to support multiple asset pairs simultaneously, reducing the fragmentation of liquidity common in other DEXs. The platform combines just-in-time liquidity, shared liquidity across pools, and customizable AMM mechanics to create deeper markets with lower costs for traders and greater control for liquidity providers."
  },
  {
    "terms": [
      "ERC721"
    ],
    "definition": "# ERC721\n\nERC721 is the Ethereum standard for non-fungible tokens (NFTs) that defines how unique tokens are created, owned, and transferred on the blockchain. Unlike fungible tokens (ERC20), each ERC721 token has a distinct tokenId and represents a unique asset or position.\n\nIn the context of automated market makers like EulerSwap, ERC721 tokens are often used to represent unique liquidity positions, allowing users to tokenize their contributions to liquidity pools. These position NFTs track specific parameters such as price ranges, asset pairs, and fee tiers.\n\nThe standard requires implementations of core functions like `transfer`, `transferFrom`, `approve`, `balanceOf`, and `ownerOf`. Smart contracts receiving ERC721 tokens typically implement the `onERC721Received` function to safely accept these tokens.\n\nWhile not explicitly shown in the EulerSwap codebase snippets provided, ERC721 tokens would interact with the system when users deposit liquidity, representing their unique positions in the Euler credit vaults and pools."
  },
  {
    "terms": [
      "EIP-712"
    ],
    "definition": "# EIP-712\n\nEIP-712 is a standard for typed structured data hashing and signing in Ethereum. It provides a consistent way to create, hash, and verify signatures for complex data structures rather than simple byte strings. In EulerSwap, it enables secure off-chain order signing with human-readable data structures.\n\nThe standard solves several key problems:\n1. It makes signed messages human-readable in wallet interfaces, so users understand what they're signing\n2. It standardizes how structured data is hashed across different implementations\n3. It prevents replay attacks by including domain-specific information in signatures\n\nEIP-712 works by defining a specific hashing scheme: `0x19 0x01 <domainSeparator> <hashStruct(message)>`, where the domain separator identifies the verifying contract and the hashStruct formats the message data consistently.\n\nIn EulerSwap's codebase, this standard supports secure parameter passing for functions, ensures consistent address derivation in functions like `computePoolAddress`, and potentially enables meta-transactions where users can sign transactions that others submit, reducing gas costs."
  },
  {
    "terms": [
      "Time-Weighted Average Market Maker (TWAMM)",
      "TWAMM"
    ],
    "definition": "# Time-Weighted Average Market Maker (TWAMM)\n\nA Time-Weighted Average Market Maker (TWAMM) is an advanced automated market maker mechanism that executes large orders gradually over an extended period to minimize price impact and reduce slippage. Unlike traditional AMMs that execute trades instantly, TWAMM divides large trades into many smaller ones spread across multiple blocks, effectively calculating a time-weighted average price. This approach protects traders from front-running and sandwich attacks while also reducing market disruption that would typically occur with large single-block trades.\n\nThe mathematical foundation of TWAMM builds upon traditional constant-product and constant-sum AMM models but introduces a temporal dimension to trade execution. By allowing trades to execute continuously over time rather than atomically in a single block, TWAMMs can provide better execution for whales and institutional traders who need to move large amounts of assets without significantly affecting market prices.\n\nTWAMM implementations typically require sophisticated on-chain infrastructure to manage order queues, virtual reserves, and continuous settlement mechanisms. Projects like Uniswap v4 have popularized this concept through their hooks system, which allows for custom trading logic including time-weighted execution strategies."
  },
  {
    "terms": [
      "Variant Maps"
    ],
    "definition": "# Variant Maps\n\nA binary encoding pattern used in the Angstrom protocol to efficiently pack multiple boolean flags into a single byte. Implemented through types like ToBOrderVariantMap and UserOrderVariantMap, these structures enable gas-efficient storage and processing of order properties such as direction (zeroForOne), internal usage flags, and signature types. Variant maps help optimize gas usage while maintaining clear, type-safe access to order properties."
  },
  {
    "terms": [
      "ECDSA"
    ],
    "definition": "# ECDSA\n\nECDSA (Elliptic Curve Digital Signature Algorithm) is a cryptographic algorithm used to create digital signatures that verify the authenticity and integrity of messages or transactions. In blockchain applications like EulerSwap, ECDSA enables secure validation that operations are authorized by the appropriate parties.\n\nThe algorithm works by generating a signature using a private key that can be verified with the corresponding public key. In Ethereum, ECDSA signatures consist of three components:\n- `r`: A point on the elliptic curve\n- `s`: A scalar value\n- `v`: A recovery identifier\n\nKey features of ECDSA in smart contracts include:\n\n1. **Address Recovery**: Extracting the signer's Ethereum address from a signature and message hash\n2. **Signature Verification**: Confirming a message was signed by a specific address\n3. **Malleability Protection**: Preventing manipulation of valid signatures\n4. **Format Support**: Handling both standard 65-byte signatures and compact EIP-2098 signatures\n\nECDSA enables critical security patterns in DeFi applications, including meta-transactions, gasless transactions, and off-chain approvals, allowing users to authorize actions without directly submitting transactions."
  },
  {
    "terms": [
      "ERC1271"
    ],
    "definition": "# ERC1271\n\nERC1271 is a standard interface for smart contracts to validate signatures. It enables contracts to implement custom signature verification logic, extending signature capabilities beyond Externally Owned Accounts (EOAs). The standard defines an `isValidSignature` function that takes a message hash and a signature, returning a specific magic value (`0x1626ba7e`) if the signature is valid.\n\n```solidity\ninterface IERC1271 {\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n```\n\nThis standard enables critical functionality including:\n\n1. **Smart contract wallets**: Allows contracts to act as signers with customizable validation logic\n2. **Multi-signature schemes**: Enables requiring multiple signatures for transaction approval\n3. **Delegated signing**: Permits designated entities to sign on behalf of a contract\n4. **Account abstraction**: Supports advanced wallet designs with arbitrary authorization logic\n\nERC1271 is widely used in DeFi, including in protocols like EulerSwap, for secure and flexible signature verification. By standardizing how contracts validate signatures, ERC1271 has become essential infrastructure for applications requiring complex authorization patterns, including DAOs, social recovery wallets, and permission-based systems."
  },
  {
    "terms": [
      "Application-Specific Sequencing (ASS)",
      "Application-Specific Sequencing",
      "(ASS)"
    ],
    "definition": "# Application-Specific Sequencing (ASS)\n\nApplication-Specific Sequencing (ASS) is a blockchain architecture pattern that allows decentralized applications to define and control the ordering of their own transactions, rather than relying on the default sequencing rules of the underlying blockchain. \n\nIn traditional blockchain systems, transactions are ordered by miners or validators based on gas prices or other protocol-defined rules. With ASS, applications implement custom sequencing logic that determines how user transactions affecting their state are ordered and executed. This provides several benefits:\n\n1. **MEV Protection**: By controlling transaction ordering, applications can minimize Miner Extractable Value (MEV) exploitation such as sandwich attacks or frontrunning, protecting users from value extraction.\n\n2. **Optimized Performance**: Applications can sequence transactions in ways that optimize for their specific needs, such as prioritizing certain transaction types or batching related operations.\n\n3. **Better User Experience**: Predictable transaction sequencing leads to more consistent outcomes for users.\n\n4. **Value Capture**: Applications can internalize value that would otherwise be extracted by external MEV searchers.\n\nUnlike full application-specific blockchains (appchains), ASS doesn't require building an entirely new blockchain. Instead, it works within existing blockchains by implementing custom rules for how transactions interacting with the application are sequenced before being included in blocks.\n\nASS is particularly valuable for DeFi applications like decentralized exchanges, lending protocols, and automated market makers where transaction ordering can significantly impact trade execution, liquidations, and other price-sensitive operations."
  },
  {
    "terms": [
      "MEV (Maximal Extractable Value)",
      "MEV",
      "Maximal Extractable Value"
    ],
    "definition": "# MEV (Maximal Extractable Value)\n\nMEV, or Maximal Extractable Value, refers to the maximum profit that can be extracted from blockchain networks by strategically manipulating the ordering, inclusion, or exclusion of transactions within blocks. Originally known as \"Miner Extractable Value,\" the concept has evolved to encompass all participants who can extract value from transaction ordering.\n\nIn blockchain systems, MEV materializes through strategies like front-running (observing and acting on pending transactions), sandwich attacks (placing transactions before and after a target), and arbitrage (exploiting price differences across exchanges). These techniques can extract value that would otherwise remain with regular users, essentially functioning as an invisible tax on transactions.\n\nEulerSwap implements several mechanisms to mitigate MEV:\n\n- **For Users**: The system processes limit orders in batches at uniform prices, preventing order manipulation and ensuring fair treatment across all participants. This approach makes sandwich attacks difficult to execute.\n\n- **For Liquidity Providers**: EulerSwap internalizes MEV competition through a \"Top of Block (ToB) Auction\" where proceeds are redistributed to liquidity providers. This prevents value leakage that would typically occur when arbitrageurs extract profit from the underlying Automated Market Maker (AMM).\n\nBy implementing these protections, EulerSwap creates a more equitable trading environment that limits censorship, ensures fair execution, and maintains value within the ecosystem rather than allowing it to be extracted by specialized MEV hunters."
  },
  {
    "terms": [
      "Orderbook"
    ],
    "definition": "# Orderbook\n\nAn orderbook is a core data structure in trading systems that maintains sorted lists of buy (bid) and sell (ask) orders for a specific asset pair. In EulerSwap, it consists of:\n\n1. A unique identifier (`PoolId`) for the trading pair\n2. Two vectors: one for bid orders and one for ask orders\n3. An optional Automated Market Maker (AMM) snapshot\n\nThe orderbook facilitates price discovery by organizing orders based on price, volume, and time priority. It works alongside EulerSwap's innovative AMM design to efficiently match trades while leveraging Euler credit vaults for enhanced liquidity.\n\nWhen a user initiates a swap, the system consults the orderbook to determine execution prices based on current market conditions. The orderbook enforces trading limits through functions like `getLimits()` and manages market depth by integrating with the AMM curve defined in the whitepaper.\n\nUnlike traditional orderbooks, EulerSwap's implementation combines order-matching with AMM functionality, creating a hybrid model that optimizes capital efficiency and maximizes liquidity across trading pairs."
  },
  {
    "terms": [
      "Top-of-Block (ToB)",
      "Top-of-Block",
      "ToB"
    ],
    "definition": "# Top-of-Block (ToB)\n\nA specialized order type in blockchain systems designed to be executed at the beginning of a new block. ToB orders receive priority placement in the transaction sequence, executing before other transactions in the same block. This mechanism allows traders to capture fleeting market inefficiencies with minimal slippage.\n\nIn the EulerSwap architecture, ToB orders include specifications for input and output asset quantities, gas limits, involved asset addresses, block number validity constraints, and recipient information. The system validates these orders as part of the block creation process, ensuring they receive preferential treatment in transaction ordering.\n\nToB orders are particularly valuable in high-frequency trading scenarios, where milliseconds can determine profitability. By guaranteeing execution at the \"top\" position of a block, traders can design strategies that capitalize on brief arbitrage opportunities or execute large trades before others can react to market movements."
  }
]